---
title: "Exploring anchored drug co-occurrence with `interact()`"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    df_print: paged
vignette: >
  %\VignetteIndexEntry{interact(): anchored drug co-occurrence}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
lang: en
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  fig.width = 7,
  fig.height = 4.5
)
library(data.table)
# library(yourPackage) # uncomment if interact() is exported from your package
```

# Purpose

`interact()` explores co-occurrence patterns of drugs within FAERS-like reports, anchored on one or more **drug roles** (PS/SS/C/I). It returns:

* the most frequent **anchor-role drugs** (computed from the **global anchor-role universe** or from the **already-scoped universe** when any *name-based* filter is used — see details below),
* the most frequent **drug combinations** under a chosen scope,
* optional **rankings** of reactions/indications/roles/sizes before and/or after filtering,
* a compact **wide “drugs_df”** derived from top combos (with a switch to use the size-agnostic reference),
* a human-readable **explanation** of the applied filters, and
* a **params** summary useful for reproducibility.

It is optimized to avoid combinatorial explosion by **never enumerating k-combinations**: results are always based on **full-set combos per report**; `size` only **restricts which report sizes are considered**, not the within-report enumeration.

---

# Inputs

All arguments are **single-call configuration**; the function reads pre-existing global `data.table`s: **`Drug`**, **`Reac`**, **`Indi`**.

## Required data in the environment

* `Drug` (data.table): columns at least `primaryid`, `substance` (character), `role_cod` (one of `"PS","SS","C","I"`).
* `Reac` (data.table): columns at least `primaryid`, `pt` (reaction Preferred Term).
* `Indi` (data.table): columns at least `primaryid`, `indi_pt` (indication Preferred Term).

The function stops if these objects are missing or are not `data.table`s.

## Arguments

### `size = 1`

Controls **which report sizes are included** in the final anchored scope. It **does not enumerate k-combinations**; instead, it selects reports whose **full-set size** matches the rule below and then derives **one full-set combo per report**.

* Modes (auto-detected):

  * **`"NA"`** (e.g., `size = NA`): *size-agnostic* (fast path). All reports (subject to filters) are used; one **full-set** combo per report is produced.
  * **`"RANK"`** (e.g., `size = 1`): choose the **k** corresponding to the *k-th most common* **report size** (computed **after** anchors/role filters). Example: `size = 2` selects reports whose **full-set size** equals the second most frequent size.
  * **`"VALUES"`** (e.g., `size = c("2","4")` or `c("2","3","4")` as strings): **keep reports whose full-set size** equals any of those exact sizes.

* Behavior:

  * No combination enumeration is ever performed. The output always contains **one combo per report** (the full set of unique substances in that report).
  * When exact sizes are requested, the function **keeps only those reports** whose full-set size matches the requested values.

### `substances = 1`

Controls **anchor drug(s)** selection.

* Modes:

  * **`"RANK"`** (default when a single positive integer): pick the substance at that rank from the selected **top drugs base** (see “Top drugs base” below).
  * **`"NAMES"`** (character vector): use the provided substance names **as anchors**. Names are validated against the current **anchor-role base** in use; missing names are handled via `on_missing`.

* Behavior:

  * Anchors are required to all co-occur in a report; otherwise the report is dropped.
  * The minimum combination size is `max(2, length(anchors))`.

### `reactions = 1`, `indications = 1`

Control optional **scope narrowing** by reaction(s) and/or indication(s). These are applied **before** role narrowing and anchoring.

* Modes:

  * **`"NA"`** (e.g., `reactions = NA`): no constraint.
  * **`"RANK"`** (single positive integer): pick the k-th most frequent reaction/indication **within the anchor-role universe**.
  * **`"NAMES"`** (character vector): constrain to reports containing any of those PTs.

* Activation: these constraints are only **used if** the corresponding merge flag is TRUE (`merge_reac`, `merge_indi`). If the flag is FALSE, the inputs are ignored.

* Missing values handling: when `"NAMES"`, unknown terms are reported via `on_missing` (see below).

### `roles = NA`

Optional **post-anchor role narrowing** (applied **after** reaction/indication scoping but **before** anchoring).

* Modes:

  * **`"NA"`**: no additional role filter.
  * **`"RANK"`** (single positive integer): keep only rows with the k-th most frequent `role_cod` in the intermediate scope.
  * **`"NAMES"`**: one or more of `"PS","SS","C","I"`.

### `merge_reac = FALSE`, `merge_indi = FALSE`

Enable/disable **reaction/indication constraints**. When TRUE, the selected reactions/indications (as per modes above) are intersected with the universe.

### `use_gen_for_drugs_df = FALSE`

Controls the **source table** used to derive `drugs_df`:

* `FALSE` (default): `drugs_df` is built from `top_comb` (which may be size-restricted).
* `TRUE`: `drugs_df` is built from `top_comb_gen` (the **size-agnostic** reference on the final anchored scope).

### `compute_rankings = "never"`

Controls **summary rankings** computation:

* `"never"`: none.
* `"before"`: rankings computed on the **anchor-role universe** (for reactions/indications) and the **DT1 scope** for roles/size (i.e., after role narrowing but before anchoring).
* `"after"`: rankings computed on the **final anchored scope** (DT2).
* `"both"`: both sets are returned.

Each ranking returns the top `n_rows`.

### `anchor_role = "I"`

Defines the **starting universe** as reports where `Drug$role_cod` is in `anchor_role` (any subset of `"PS","SS","C","I"`). Early frequency tables derive from this universe.

### `n_rows = 10`

Number of rows to show for **top tables** (top drugs, combos, rankings).

### `on_missing = "stop"`

How to react to **missing names** in `"NAMES"` modes (`substances`, `reactions`, `indications`):

* `"stop"`: error.
* `"proceed"`: continue with present values; message lists missing ones.
* `"ask"`: interactive menu if running interactively, otherwise errors with guidance.

### `save = FALSE`, `file_name = "faers_exploring_analysis"`

If `TRUE`, writes an Excel file (`.xlsx`) with one sheet per output component (requires `writexl`).

---

# Top drugs base

`top_drugs` (and rank-based anchor selection) are computed from:

* the **global anchor-role universe** (ignoring reaction/indication/role filters), **unless**
* **any name-based filter is present** among: `substances` (anchors by name), `reactions` (with `merge_reac=TRUE`), `indications` (with `merge_indi=TRUE`), or `roles` (post-anchor by name).
  In that case, `top_drugs` are computed from the **already-scoped DT1** to reflect the name-based constraints.

---

# Processing pipeline (high level)

1. **Validate inputs** and detect modes (`NA`/`RANK`/`NAMES`/`VALUES`). Coerce and check against dictionaries (`Drug$substance`, `Reac$pt`, `Indi$indi_pt`, role codes).

2. Build **anchor-role universe** (`primaryid`s with `role_cod %in% anchor_role`).

3. Apply **reaction/indication constraints** if enabled (`merge_*`), narrowing to reports that contain selected PTs.

4. Apply **post-anchor role filter** (optional `"RANK"`/`"NAMES"`).

5. Compute `top_drugs` from either the **global anchor-role universe** or the **scoped** universe (see “Top drugs base”).

6. Determine **anchors** (from rank or names) and keep only reports that contain **all anchors**.

7. Build **size distribution** in the final scope and determine **eligible reports** per size rules (note: **no combination enumeration** is performed).

8. Build **combinations**:

   * **`top_comb_gen`**: always the **size-agnostic** full-set path (one combo per report in the final anchored scope).
   * **`top_comb`**:

     * if `size = NA`: equals `top_comb_gen`;
     * otherwise: **full-set** combos **only from reports** whose full-set size matches the selected size(s).

9. Optionally compute **rankings** `"before"`/`"after"`.

10. Produce **presentation helpers** (`drugs_df`, `explanation`) and assemble `out`.

    * `drugs_df` is built from `top_comb` by default, or from `top_comb_gen` when `use_gen_for_drugs_df = TRUE`.

11. Optionally **save** to Excel.

---

# Outputs

`interact()` returns a named `list`:

* **`top_drugs`** (`data.table`):

  * Columns: `substance`, `N`.
  * Scope: **global anchor-role** or **scoped** (see “Top drugs base”).
  * Use: drives rank-based anchor selection.

* **`top_comb`** (`data.table`):

  * Columns: `combo` (e.g., `"A + B + C"`), `N`, `perc`.
  * Scope: **final anchored scope**, **one full-set combo per report**.
  * If `size` is provided, **only reports whose full-set size equals the chosen size(s)** contribute.
  * `perc` is the within-table percentage (`round(100*N/sum(N), 1)`).

* **`top_comb_gen`** (`data.table`):

  * Same columns as `top_comb`.
  * Scope: **final anchored scope**, **always** size-agnostic (all report sizes). Serves as a stable reference.

* **`drugs_df`** (`data.frame`):

  * A **wide** table derived from `top_comb` (or from `top_comb_gen` if `use_gen_for_drugs_df=TRUE`), with columns `drug1, drug2, ..., drugK`.
  * `drug1` is the **first anchor** if anchors exist, otherwise the top substance from `top_drugs`.
  * For each top combo, everything except `drug1` is spread across `drug2..`. The number of columns adapts to the largest combo.

* **`explanation`** (`character` vector):

  * Bulleted strings describing the **exact** filters/choices applied (anchor roles, anchors, whether reaction/indication merges were enabled and which terms were used, role filter, size selection, rankings timing). Also printed as messages.

* **`params`** (`list` of simple vectors):

  * Echoes the **effective parameters** actually applied:

    * `anchor_role`, `merge_reac`, `merge_indi`,
    * `reactions`/`indications` used (or `NA`),
    * `roles_applied` used (or `NA`),
    * `size_used` (or `NA`),
    * `anchors_applied`.

* **`rankings`** (`list` or `NULL`):

  * May include any of the following, each as a `data.table` limited to `n_rows`:

    * `mr_reac_beg`, `mr_indi_beg`, `mr_role_beg`, `mr_size_beg` (when `"before"`/`"both"`),
    * `mr_reac_end`, `mr_indi_end`, `mr_roles_end`, `mr_size_end` (when `"after"`/`"both"`).

If `save = TRUE`, an Excel workbook is created with sheets:
`top_drugs`, `top_comb`, `top_comb_gen`, `drugs_df`, `explanation`, any `rankings` present, and a `params` sheet.

---

# Interpretation guidance

* **`top_drugs`** helps you see which substances dominate the **anchor-role** subset (global or scoped, depending on filters). If you pick anchors by rank, they come from here.
* **`top_comb`** answers: *“Among reports that contain all anchors and pass filters, which **full-set** (report-level) combinations are most common?”*
  If `size` is given, it answers: *“Same as above, but **only for reports whose full-set size** equals the selected size(s).”*
* **`top_comb_gen`** is a **size-agnostic baseline** on the final scope; compare it to `top_comb` to understand how size selection impacted results.
* **`drugs_df`** can be derived either from the size-restricted results or from the size-agnostic baseline via `use_gen_for_drugs_df`.

---

# Computational time & resource notes

Let:

* `R` = number of reports in the anchor-role universe,
* `R'` = reports after reac/indi/role filters,
* `k_i` = number of unique substances in report `i` after filters.

## Single full-set per report (always)

* Work per report is essentially **O($k_i$)** to sort and concatenate unique substances into a single label.
* Overall complexity ≈ **O($\sum k_i$)** across retained reports (linear in total unique drug mentions).
* This is **very fast** and scales to large datasets.

> Note: **No** k-combination enumeration is performed. Using `size` merely **selects report sizes**, which is inexpensive (count-then-filter).

---

# Failure modes & messages

* Missing globals: stops if `Drug`, `Reac`, `Indi` do not exist or are not `data.table`s.
* Empty universes: stops when any filtering stage yields zero reports (e.g., anchor role has no reports; no reports contain all anchors; reac/indi/role constraints remove everything).
* Invalid codes/names: stops on invalid `role_cod` inputs; with `"NAMES"` modes, missing terms are handled per `on_missing`.
* Rank out of bounds: rank selections are **clamped** to valid range.
* Saving: stops if `writexl` is missing when `save = TRUE`.

---

# Examples

> Assume the usual FAERS-like tables are loaded as `data.table`s in the environment.

## 1) Quick overview with size-agnostic full sets

```{r, eval=FALSE}
out <- interact(
  size = NA,                  # size-agnostic: one full-set combo per report
  substances = 1,             # anchor = top substance (base depends on filters)
  anchor_role = "I",          # interacting drugs
  n_rows = 15,                # show more rows
  compute_rankings = "before" # see distributions before anchoring
)
out$top_drugs
out$top_comb       # one full-set combo per report (top 15)
out$rankings$mr_size_beg
```

## 2) Reports of size 2 (pairs) that include a named anchor

```{r, eval=FALSE}
out <- interact(
  size = "2",                         # keep only reports whose full-set size is 2
  substances = c("AMOXICILLIN"),      # require this anchor
  anchor_role = c("PS","SS"),         # suspect roles
  roles = c("PS","SS"),               # keep suspect drugs post-anchor
  compute_rankings = "after",
  n_rows = 20
)
out$top_comb       # most frequent full-set pairs that include AMOXICILLIN
out$drugs_df       # drug1 is AMOXICILLIN; drug2 shows the partner
```

## 3) Reports of size 3 including two anchors, filtered by a reaction name

```{r, eval=FALSE}
out <- interact(
  size = "3",
  substances = c("IBUPROFEN","PARACETAMOL"),  # both must co-occur
  merge_reac = TRUE,
  reactions = c("NAUSEA"),                    # keep reports with NAUSEA
  anchor_role = "C",
  on_missing = "proceed"                      # if a name is absent, continue
)
out$explanation
out$top_comb
```

## 4) Compare size-agnostic vs size-specific results

```{r, eval=FALSE}
out <- interact(
  size = c("2","3"),             # restrict to reports sized 2 or 3 (full sets)
  substances = 1,                # top anchor
  compute_rankings = "both",
  n_rows = 10
)
out$top_comb       # full sets from size-2/3 reports only
out$top_comb_gen   # same scope but includes all sizes (size-agnostic)
```

## 5) Use ranks for reactions/indications

```{r, eval=FALSE}
out <- interact(
  size = NA,
  substances = 1,
  merge_reac = TRUE,
  reactions = 3,           # 3rd most frequent reaction in anchor-role universe
  merge_indi = TRUE,
  indications = 1,         # top indication
  compute_rankings = "after"
)
out$params$reactions     # the resolved reaction PT
out$params$indications   # the resolved indication PT
```

## 6) Save to Excel

```{r, eval=FALSE}
out <- interact(
  size = NA,
  substances = c("WARFARIN"),
  anchor_role = c("PS","SS","C","I"),
  save = TRUE,
  file_name = "faers_exploring_analysis.xlsx"
)
# Console prints the normalized path if successful
```

---

# Tips & best practices

* **Start size-agnostic**: begin with `size = NA` to understand the landscape, then optionally restrict to exact report sizes.
* **Use anchors**: even one anchor reduces scope and focuses results.
* **Role consistency**: when exploring suspect relationships, set both `anchor_role` and `roles` to suspect codes to keep semantics aligned.
* **Compare paths**: `top_comb` vs `top_comb_gen` tells you how much your size restriction is shaping the results.
* **Reproducibility**: retain `out$params` and `out$explanation` alongside your tables when reporting.
* **Missing terms**: prefer `on_missing = "proceed"` during exploratory analysis, and switch to `"stop"` in pipelines.
* **Control `drugs_df` base**: set `use_gen_for_drugs_df = TRUE` to build the wide table from the size-agnostic baseline.

---

# Reference: role codes

* `PS` = Primary suspect
* `SS` = Secondary suspect
* `C`  = Concomitant
* `I`  = Interacting

---

# Session info

```{r}
sessionInfo()
```
