---
title: "Exploring anchored drug co-occurrence with `interact()`"
author: "Your Name"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    df_print: paged
vignette: >
  %\VignetteIndexEntry{interact(): anchored drug co-occurrence}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
lang: en
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  fig.width = 7,
  fig.height = 4.5
)
library(data.table)
# library(yourPackage) # uncomment if interact() is exported from your package
```

# Purpose

`interact()` explores co-occurrence patterns of drugs within FAERS-like reports, anchored on one or more **drug roles** (PS/SS/C/I). It returns:

* the most frequent **anchor-role drugs**,
* the most frequent **drug combinations** under a chosen scope,
* optional **rankings** of reactions/indications/roles/sizes before and/or after filtering,
* a compact **wide “drugs_df”** derived from top combos,
* a human-readable **explanation** of the applied filters, and
* a **params** summary useful for reproducibility.

It is optimized to avoid combinatorial explosion when you don’t request exact combination sizes.

---

# Inputs

All arguments are **single-call configuration**; the function reads pre-existing global `data.table`s: **`Drug`**, **`Reac`**, **`Indi`**.

## Required data in the environment

* `Drug` (data.table): columns at least `primaryid`, `substance` (character), `role_cod` (one of `"PS","SS","C","I"`).
* `Reac` (data.table): columns at least `primaryid`, `pt` (reaction Preferred Term).
* `Indi` (data.table): columns at least `primaryid`, `indi_pt` (indication Preferred Term).

The function stops if these objects are missing or are not `data.table`s.

## Arguments

### `size = 1`

Controls **combination size selection** in the final anchored scope.

* Modes (auto-detected):

  * **`"NA"`** (e.g., `size = NA`): *no size enumeration* (fast path). One **full-set** combo per report (i.e., all unique substances in the report) is produced.
  * **`"RANK"`** (e.g., `size = 1`): choose the **k** corresponding to the *k-th most common* report size (computed after anchors/role filters). Example: `size = 2` selects the second most frequent size.
  * **`"VALUES"`** (e.g., `size = c("2","4")` or `c("2","3","4")` as strings): enumerate **exact sizes**. This may be expensive; see “Computational cost”.

* Behavior:

  * If `sizes` are **NULL** (i.e., mode `"NA"`), the function **does not enumerate combinations**: it emits one combo per report (the set of all substances in the report).
  * If exact sizes are requested, it **enumerates** k-combinations that **must include all anchors** (if anchors exist). Reports with size `< max(2, #anchors)` are excluded.

### `substances = 1`

Controls **anchor drug(s)** selection.

* Modes:

  * **`"RANK"`** (default when a single positive integer): pick the substance at that rank from **`top_drugs_full`** (the frequency of substances among reports within `anchor_role`, before any reaction/indication/role narrowing).
  * **`"NAMES"`** (character vector): use the provided substance names **as anchors**. Names are validated against the current **anchor-role universe**; missing names are handled via `on_missing`.

* Behavior:

  * Anchors are required to all co-occur in a report; otherwise the report is dropped.
  * The minimum combination size is `max(2, length(anchors))`.

### `reactions = 1`, `indications = 1`

Control optional **scope narrowing** by reaction(s) and/or indication(s). These are applied **before** role narrowing and before anchoring.

* Modes:

  * **`"NA"`** (e.g., `reactions = NA`): no constraint.
  * **`"RANK"`** (single positive integer): pick the k-th most frequent reaction/indication **within the anchor-role universe**.
  * **`"NAMES"`** (character vector): constrain to reports containing any of those PTs.

* Activation: these constraints are only **used if** the corresponding merge flag is TRUE (`merge_reac`, `merge_indi`). If the flag is FALSE, the inputs are ignored.

* Missing values handling: when `"NAMES"`, unknown terms are reported via `on_missing` (see below).

### `roles = NA`

Optional **post-anchor role narrowing** (applied **after** reaction/indication scoping but **before** combos).

* Modes:

  * **`"NA"`**: no additional role filter.
  * **`"RANK"`** (single positive integer): keep only rows with the k-th most frequent `role_cod` in the intermediate scope.
  * **`"NAMES"`**: one or more of `"PS","SS","C","I"`.

### `merge_reac = FALSE`, `merge_indi = FALSE`

Enable/disable **reaction/indication constraints**. When TRUE, the selected reactions/indications (as per modes above) are intersected with the universe.

### `compute_rankings = "never"`

Controls **summary rankings** computation:

* `"never"`: none.
* `"before"`: rankings computed on the **anchor-role universe** (for reactions/indications) and the **DT1 scope** for roles/size (i.e., after role narrowing but before anchoring/size).
* `"after"`: rankings computed on the **final anchored scope** (DT2).
* `"both"`: both sets are returned (useful for comparing drift due to filters).

Each ranking returns the top `n_rows`.

### `anchor_role = "I"`

Defines the **starting universe** as reports where `Drug$role_cod` is in `anchor_role` (any subset of `"PS","SS","C","I"`). All early frequency tables and the initial **top drugs** derive from this universe.

### `n_rows = 10`

Number of rows to show for **top tables** (top drugs, combos, rankings).

### `on_missing = "stop"`

How to react to **missing names** in `"NAMES"` modes (`substances`, `reactions`, `indications`):

* `"stop"`: error.
* `"proceed"`: continue with present values; message lists missing ones.
* `"ask"`: interactive menu if running interactively, otherwise errors with guidance.

### `save = FALSE`, `file_name = "faers_exploring_analysis"`

If `TRUE`, writes an Excel file (`.xlsx`) with one sheet per output component (requires `writexl`).

---

# Processing pipeline (high level)

1. **Validate inputs** and detect modes (`NA`/`RANK`/`NAMES`/`VALUES`). Coerce and check against dictionaries (`Drug$substance`, `Reac$pt`, `Indi$indi_pt`, role codes).

2. Build **anchor-role universe** (`primaryid`s with `role_cod %in% anchor_role`).

3. Apply **reaction/indication constraints** if enabled (`merge_*`), narrowing to reports that contain selected PTs.

4. Apply **post-anchor role filter** (optional `"RANK"`/`"NAMES"`).

5. Compute **top_drugs_full** strictly from the **anchor-role universe** (ignores reac/indi/role filters).

6. Determine **anchors** (from rank or names) and keep only reports that contain **all anchors**.

7. Build **size distribution** in the final scope and determine **eligible reports** per size rules.

8. Build **combinations**:

   * **Fast path** when `sizes = NULL` (i.e., `size = NA`): emit **one** combo per report (the full set); no enumeration.
   * **Exact sizes**: enumerate k-combinations; if anchors exist, they are enforced in every combo.

9. Optionally compute **rankings** `"before"`/`"after"`.

10. Produce **presentation helpers** (`drugs_df`, `explanation`) and assemble `out`.

11. Optionally **save** to Excel.

---

# Outputs

`interact()` returns a named `list`:

* **`top_drugs`** (`data.table`):

  * Columns: `substance`, `N`.
  * Scope: **anchor-role universe** (ignores reac/indi/role filters).
  * Use: shows the head (`n_rows`) of the global ranking driving rank-based anchor selection.

* **`top_comb`** (`data.table`):

  * Columns: `combo` (e.g., `"A + B + C"`), `N`, `perc`.
  * Scope: **final anchored scope** with **selected sizes** *if provided*; otherwise **fast full-set** per report (one combo per report).
  * `perc` is the within-table percentage (`round(100*N/sum(N), 1)`).

* **`top_comb_gen`** (`data.table`):

  * Same columns as `top_comb`.
  * Scope: **final anchored scope**, **always** fast full-set path (ignores `size` input and enumerations). Useful as a stable reference.

* **`drugs_df`** (`data.frame`):

  * A **wide** table derived from `top_comb`, with columns `drug1, drug2, ..., drugK`.
  * `drug1` is the **first anchor** if anchors exist, otherwise the top substance from `top_drugs`.
  * For each top combo, everything except `drug1` is spread across `drug2..`. The number of columns adapts to the largest combo.

* **`explanation`** (`character` vector):

  * Bulleted strings describing the **exact** filters/choices applied (anchor roles, anchors, whether reaction/indication merges were enabled and which terms were used, role filter, size selection, rankings timing). Also printed as messages.

* **`params`** (`list` of simple vectors):

  * Echoes the **effective parameters** that were **actually applied**, post-validation and rank/name resolution:

    * `anchor_role`, `merge_reac`, `merge_indi`,
    * `reactions`/`indications` actually used (or `NA`),
    * `roles_applied` actually used (or `NA`),
    * `size_used` actually used (or `NA`),
    * `anchors_applied` (character vector).

* **`rankings`** (`list` or `NULL`):

  * May include any of the following, each as a `data.table` limited to `n_rows`:

    * `mr_reac_beg`, `mr_indi_beg`, `mr_role_beg`, `mr_size_beg` (when `"before"`/`"both"`),
    * `mr_reac_end`, `mr_indi_end`, `mr_roles_end`, `mr_size_end` (when `"after"`/`"both"`).

If `save = TRUE`, an Excel workbook is created with sheets:
`top_drugs`, `top_comb`, `top_comb_gen`, `drugs_df`, `explanation`, any `rankings` present, and a `params` sheet.

---

# Interpretation guidance

* **`top_drugs`** helps you see which substances dominate the **anchor-role** subset. If you pick anchors by rank, they come from here.
* **`top_comb`** answers: *“Among reports that contain all anchors and pass filters, which (selected-size) combinations are most common?”*
  If `size = NA`, it answers: *“Which **full report sets** (all substances observed together) are most common?”*.
* **`top_comb_gen`** is a **size-agnostic baseline** on the final scope; compare it to `top_comb` to understand how size selection impacted results.
* **`rankings`** before vs after filtering help you **quantify the effect** of anchor/role/size constraints on the distribution of reactions, indications, roles, and sizes.

---

# Computational time & resource notes

Let:

* `R` = number of reports in the anchor-role universe,
* `R'` = reports after reac/indi/role filters,
* `k_i` = number of unique substances in report `i` after filters,
* `\u0304{k}` (written as $\bar{k}$) = average $k_i$ across retained reports,
* `A` = number of anchors.

## Fast path (`size = NA`)

* Work per report is essentially **O($k_i$)** to sort and concatenate unique substances into a single label.
* Overall complexity ≈ **O($\sum k_i$)** across `R'` reports (linear in total unique drug mentions).
* This is **very fast** and scales to large datasets.

## Exact sizes (`size` in `"RANK"` or `"VALUES"`)

* For a given $k$, enumerating combinations is **O($\sum \binom{k_i}{k}$)**. With multiple $k$ values, sum across ks.

* With **anchors**, every combo **must include all anchors**. This reduces enumeration to:

  * Choose $r = k - A$ from the **non-anchor** set in a report. Cost per report becomes **$\binom{k_i - A}{k - A}$** (if $k \ge A$), often much smaller.

* Practical guidance:

  * Prefer the **fast path** unless you specifically need fixed-size combos.
  * If using exact sizes, keep $k$ small (e.g., 2–4) and use **anchors** to reduce $k_i - A$.
  * Large $k$ or large $k_i$ lead to **combinatorial growth** and high memory/time.

## Other contributors

* Frequency tables (`.N, by = ...`) are standard `data.table` group-bys ~ **O(n)** with hashing; these are not usually the bottleneck.
* Memory is dominated by the number of enumerated combos kept in `combo_labels`. With `size = NA`, memory is minimal (≈ one row per report).

---

# Failure modes & messages

* Missing globals: stops if `Drug`, `Reac`, `Indi` do not exist or are not `data.table`s.
* Empty universes: stops when any filtering stage yields zero reports (e.g., anchor role has no reports; no reports contain all anchors; reac/indi/role constraints remove everything).
* Invalid codes/names: stops on invalid `role_cod` inputs; with `"NAMES"` modes, missing terms are handled per `on_missing`.
* Rank out of bounds: rank selections are **clamped** to valid range (e.g., asking for rank 100 when only 20 exist gives rank 20), so you won’t get an index error, but a subtle change in selected entity.
* Saving: stops if `writexl` is missing when `save = TRUE`.

---

# Examples

> Assume the usual FAERS-like tables are loaded as `data.table`s in the environment.

## 1) Quick overview with fast path (no size enumeration)

```{r, eval=FALSE}
out <- interact(
  size = NA,                  # fast full-set combos
  substances = 1,             # anchor = top substance in anchor-role universe
  anchor_role = "I",          # interacting drugs
  n_rows = 15,                # show more rows
  compute_rankings = "before" # see distributions before anchoring
)
out$top_drugs
out$top_comb       # one full-set combo per report (top 15)
out$rankings$mr_size_beg
```

## 2) Exact pairs that include a named anchor

```{r, eval=FALSE}
out <- interact(
  size = "2",                         # exact pairs
  substances = c("AMOXICILLIN"),      # require this anchor
  anchor_role = c("PS","SS"),         # suspect roles
  roles = c("PS","SS"),               # keep suspect drugs post-anchor
  compute_rankings = "after",
  n_rows = 20
)
out$top_comb       # most frequent pairs that include AMOXICILLIN
out$drugs_df       # drug1 is AMOXICILLIN; drug2 shows the partner
```

## 3) Triplets including two anchors, filtered by a reaction name

```{r, eval=FALSE}
out <- interact(
  size = "3",
  substances = c("IBUPROFEN","PARACETAMOL"),  # both must co-occur
  merge_reac = TRUE,
  reactions = c("NAUSEA"),                    # keep reports with NAUSEA
  anchor_role = "C",
  on_missing = "proceed"                      # if a name is absent, continue
)
out$explanation
out$top_comb
```

## 4) Compare size-agnostic vs size-specific results

```{r, eval=FALSE}
out <- interact(
  size = c("2","3"),             # enumerate pairs and triplets
  substances = 1,                # top anchor
  compute_rankings = "both",
  n_rows = 10
)
out$top_comb       # pairs/triplets only
out$top_comb_gen   # same scope but full-set per report
```

## 5) Use ranks for reactions/indications

```{r, eval=FALSE}
out <- interact(
  size = NA,
  substances = 1,
  merge_reac = TRUE,
  reactions = 3,           # 3rd most frequent reaction in anchor-role universe
  merge_indi = TRUE,
  indications = 1,         # top indication
  compute_rankings = "after"
)
out$params$reactions     # the resolved reaction PT
out$params$indications   # the resolved indication PT
```

## 6) Save to Excel

```{r, eval=FALSE}
out <- interact(
  size = NA,
  substances = c("WARFARIN"),
  anchor_role = c("PS","SS","C","I"),
  save = TRUE,
  file_name = "faers_exploring_analysis.xlsx"
)
# Console prints the normalized path if successful
```

---

# Tips & best practices

* **Start fast**: begin with `size = NA` to understand the landscape, then move to exact sizes if needed.
* **Use anchors**: even one anchor dramatically reduces enumeration when `size` is fixed.
* **Role consistency**: when exploring suspect relationships, set both `anchor_role` and `roles` to suspect codes to keep semantics aligned.
* **Compare paths**: `top_comb` vs `top_comb_gen` tells you how much your size selection is shaping the results.
* **Reproducibility**: retain `out$params` and `out$explanation` alongside your tables when reporting.
* **Missing terms**: prefer `on_missing = "proceed"` during exploratory analysis, and switch to `"stop"` in pipelines.

---

# Reference: role codes

* `PS` = Primary suspect
* `SS` = Secondary suspect
* `C`  = Concomitant
* `I`  = Interacting

---

# Session info

```{r}
sessionInfo()
```

